// Copyright (c) 2017 Iori Mizutani
//
// Use of this source code is governed by The MIT License
// that can be found in the LICENSE file.

package filtering

import (
	"sort"
)

// Nodes store a slice of *node to
// sort by p to build OptimalBST
type Nodes []*node

type node struct {
	filter          string
	offset          int
	notificationURI string
	p               float64
}

// Internal helper methods -----------------------------------------------------

func (nd *node) equal(want *node) (ok bool, got *node, wanted *node) {
	if nd.filter != want.filter ||
		nd.offset != want.offset ||
		nd.p != want.p {
		return false, nd, want
	}
	return true, nil, nil
}

func (nds *Nodes) sortByP() {
	sort.Slice(*nds, func(i, j int) bool {
		return (*nds)[i].p > (*nds)[j].p
	})
	return
}

// NewNodes returns a pointer to Nodes
// generated by the given Subscriptions
func NewNodes(sub Subscriptions) Nodes {
	nds := make(Nodes, sub.Length())
	i := 0
	for _, fs := range sub.Keys() {
		info := sub.Get(fs)
		nds[i] = &node{fs, info.Offset, info.NotificationURI, info.EntropyValue}
		i++
	}
	nds.sortByP()
	return nds
}
