// Copyright (c) 2017 Iori Mizutani
//
// Use of this source code is governed by The MIT License
// that can be found in the LICENSE file.

package filtering

import (
	"sort"
)

// HuffmanCodes store a slice of *entry to
// sort by p to build HuffmanTree
type HuffmanCodes []*entry

type entry struct {
	filter          string
	offset          int
	notificationURI string
	p               float64
}

func (ent *entry) equal(want *entry) (ok bool, got *entry, wanted *entry) {
	if ent.filter != want.filter ||
		ent.offset != want.offset ||
		ent.p != want.p {
		return false, ent, want
	}
	return true, nil, nil
}

func (hc *HuffmanCodes) sortByP() {
	sort.Slice(*hc, func(i, j int) bool {
		return (*hc)[i].p > (*hc)[j].p
	})
	return
}

/*
func (hc HuffmanCodes) autoencode(compLimit int) *HuffmanCodes {
	// write bits to last and penultimate
	hc.sortByP()
	last := hc[0]
	penultimate := hc[1]

	if len(hc) == 2 {
		return &hc
	}

	// If the pair exceeds the compLimit
	var ent *entry
	if max(last.compLevel+1, penultimate.compLevel+1) > compLimit || compLimit == -1 {
	} else { // if not, make a new composition
		ent = &entry{
			filter:    "",
			offset:    0,
			p:         penultimate.p + last.p,
			compLevel: max(last.compLevel+1, penultimate.compLevel+1),
			group:     []*entry{penultimate, last},
			branch:    &HuffmanTree{},
		}
	}

	// Remove last and penultimate and add the composition
	nhc := append(hc[2:], ent)

	return nhc.autoencode(compLimit)
}
*/

// NewHuffmanCodes returns a pointer to HuffmanCodes
// generated by the given Subscriptions
func NewHuffmanCodes(sub *Subscriptions) *HuffmanCodes {
	hc := make(HuffmanCodes, len(*sub))
	i := 0
	for fs, info := range *sub {
		hc[i] = &entry{fs, 0, info.NotificationURI, info.EntropyValue}
		i++
	}
	hc.sortByP()
	return &hc
}
